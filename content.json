{"meta":{"title":"编程、悟道","subtitle":"无欲速，无见小利。欲速则不达，见小利则大事不成","description":"砥砺前行","author":"Shawn","url":"http://yoursite.com","root":"/"},"pages":[{"title":"尝试了解一下哥吧^_^","date":"2019-12-12T02:46:55.000Z","updated":"2020-01-13T03:01:56.757Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"江杰（Shawn.Jiang） 我什么都能干 除了生孩子 甲戌年甲戌月己巳日生 现居：浙江-杭州 本人邮箱jiangjiejobs@163.com，欢迎交流讨论 菜鸟Github，不常更新 无聊者知乎"}],"posts":[{"title":"Android属性动画记录","slug":"属性动画","date":"2020-01-03T06:09:18.760Z","updated":"2020-01-03T06:10:20.432Z","comments":true,"path":"2020/01/03/属性动画/","link":"","permalink":"http://yoursite.com/2020/01/03/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/","excerpt":"属性动画 主要概念 Duration Time interpolation Repeat count and behavior Animator sets Frame refresh delay ValueAnimator执行过程 ValueAnimator对象跟踪动画的时间安排，例如动画运行了多长时间，以及正在设置动画的属性的当前值。ValueAnimator封装了一个TimeInterpolator和TypeEvaluator，后者定义了动画插值，而TypeEvaluator定义了如何为动画属性计算值。要开启动画，创建一个ValueAnimator并为其提供要设置动画的属性的开始和结束值，以及动画的持续时间。当您调用start（）时，动画开始。在整个动画过程中，ValueAnimator会根据动画的持续时间和经过的时间来计算0到1之间的经过分数（fraction）。逝去的分数表示动画已完成的时间百分比，0表示0％，1表示100％。当ValueAnimator完成计算经过的分数时，它将调用当前设置的TimeInterpolator，以计算插值分数（按照一定公式转化fraction）。计算插值的分数时，ValueAnimator调用适当的TypeEvaluator，以基于插值的分数，动画的起始值和结束值来计算要设置动画的对应属性值。 使用 基本使用 1ValueAnimator animation = ValueAnimator.ofFloat(0f, 100f);2animation.setDuration(1000);3animation.start(); 还可以通过执行以下操作来指定要制作动画的自定义类型 1ValueAnimator animation = ValueAnimator.ofObject(new MyTypeEvaluator(), startPropertyValue, endPropertyValue);2animation.setDuration(1000);3animation.start(); 通过将AnimatorUpdateListener添加到ValueAnimator对象来使用动画的值，如以下代码所示： 1animation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;2 @Override3 public void onAnimationUpdate(ValueAnimator updatedAnimation) &#123;4 // You can use the animated value in a property that uses the5 // same type as the animation. In this case, you can use the6 // float value in the translationX property.7 float animatedValue = (float)updatedAnimation.getAnimatedValue();8 textView.setTranslationX(animatedValue);9 &#125;10 &#125;); ObjectAnimator使用 1ObjectAnimator animation = ObjectAnimator.ofFloat(textView, \"translationX\", 100f);2animation.setDuration(1000);3animation.start(); 针对执行动画的属性在对应对象中必须要包含对应属性的set与get方法 AnimatorSet组合多个动画AnimatorSet组合多个Animator，并与许嵌套AnimatorSet，如下代码所示： 1AnimatorSet bouncer = new AnimatorSet();2bouncer.play(bounceAnim).before(squashAnim1);3bouncer.play(squashAnim1).with(squashAnim2);4bouncer.play(squashAnim1).with(stretchAnim1);5bouncer.play(squashAnim1).with(stretchAnim2);6bouncer.play(bounceBackAnim).after(stretchAnim2);7ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, \"alpha\", 1f, 0f);8fadeAnim.setDuration(250);9AnimatorSet animatorSet = new AnimatorSet();10animatorSet.play(bouncer).before(fadeAnim);11animatorSet.start(); 上述代码片段含义即： Plays bounceAnim. Plays squashAnim1, squashAnim2, stretchAnim1, and stretchAnim2 at the same time. Plays bounceBackAnim. Plays fadeAnim. 常用监听器不细述，具体使用时查看即可 对ViewGroup对象的布局更改进行动画处理(LayoutTransition)使用LayoutTransition类在ViewGroup中为布局更改动画。将视图添加到视图组中或从视图组中删除视图时，或者使用VISIBLE，INVISIBLE或GONE调用视图的setVisibility（）方法时，ViewGroup中的视图都会经过显示和消失的动画。添加或删除视图时，ViewGroup中的其余视图也可以设置为新位置的动画。您可以通过调用setAnimator（）并使用以下LayoutTransition常量之一传入Animator对象，来在LayoutTransition对象中定义以下动画： APPEARING-标记，指示在容器中显示的项目上运行的动画。 CHANGE_APPEARING-一个标志，指示在由于新项目出现在容器中而发生变化的项目上运行的动画。 DISAPPEARING-一个标志，指示在从容器中消失的项目上运行的动画。 CHANGE_DISAPPEARING-一个标志，指示在由于容器中某个项目消失而发生变化的项目上运行的动画。 您可以为这四种类型的事件定义自己的自定义动画，以自定义布局过渡的外观，或者只是告诉动画系统使用默认动画。如何在XML中为ViewGroups启用默认布局转换。您唯一需要做的就是将ViewGroup的android：animateLayoutchanges属性设置为true。例如 1&lt;LinearLayout2 android:orientation=\"vertical\"3 android:layout_width=\"wrap_content\"4 android:layout_height=\"match_parent\"5 android:id=\"@+id/verticalContainer\"6 android:animateLayoutChanges=\"true\" /&gt; 将此属性设置为true会自动为从ViewGroup添加或删除的View以及ViewGroup中的其余View设置动画。 StateListAnimator先预先进行xml定义 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;3 &lt;!-- the pressed state; increase x and y size to 150% --&gt;4 &lt;item android:state_pressed=\"true\"&gt;5 &lt;set&gt;6 &lt;objectAnimator android:propertyName=\"scaleX\"7 android:duration=\"@android:integer/config_shortAnimTime\"8 android:valueTo=\"1.5\"9 android:valueType=\"floatType\"/&gt;10 &lt;objectAnimator android:propertyName=\"scaleY\"11 android:duration=\"@android:integer/config_shortAnimTime\"12 android:valueTo=\"1.5\"13 android:valueType=\"floatType\"/&gt;14 &lt;/set&gt;15 &lt;/item&gt;16 &lt;!-- the default, non-pressed state; set x and y size to 100% --&gt;17 &lt;item android:state_pressed=\"false\"&gt;18 &lt;set&gt;19 &lt;objectAnimator android:propertyName=\"scaleX\"20 android:duration=\"@android:integer/config_shortAnimTime\"21 android:valueTo=\"1\"22 android:valueType=\"floatType\"/&gt;23 &lt;objectAnimator android:propertyName=\"scaleY\"24 android:duration=\"@android:integer/config_shortAnimTime\"25 android:valueTo=\"1\"26 android:valueType=\"floatType\"/&gt;27 &lt;/set&gt;28 &lt;/item&gt;29&lt;/selector&gt; 绑定到相对应控件上 1&lt;Button android:stateListAnimator=\"@xml/animate_scale\"2 ... /&gt; 或者是通过设置AnimatorInflater.loadStateListAnimator（）方法，然后使用View.setStateListAnimator（）方法将动画分配给您的视图；或者，可以使用AnimatedStateListDrawable在状态更改之间播放可绘制的动画，而不是为视图的动画设置动画。默认情况下，Android 5.0中的某些系统小部件使用这些动画。下面的示例演示如何将AnimatedStateListDrawable定义为XML资源： 1&lt;!-- res/drawable/myanimstatedrawable.xml --&gt;2&lt;animated-selector3 xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;45 &lt;!-- provide a different drawable for each state--&gt;6 &lt;item android:id=\"@+id/pressed\" android:drawable=\"@drawable/drawableP\"7 android:state_pressed=\"true\"/&gt;8 &lt;item android:id=\"@+id/focused\" android:drawable=\"@drawable/drawableF\"9 android:state_focused=\"true\"/&gt;10 &lt;item android:id=\"@id/default\"11 android:drawable=\"@drawable/drawableD\"/&gt;1213 &lt;!-- specify a transition --&gt;14 &lt;transition android:fromId=\"@+id/default\" android:toId=\"@+id/pressed\"&gt;15 &lt;animation-list&gt;16 &lt;item android:duration=\"15\" android:drawable=\"@drawable/dt1\"/&gt;17 &lt;item android:duration=\"15\" android:drawable=\"@drawable/dt2\"/&gt;18 ...19 &lt;/animation-list&gt;20 &lt;/transition&gt;21 ...22&lt;/animated-selector&gt; TypeEvaluator Interpolators KeyFrames关键帧对象由时间/值对组成，可让您在动画的特定时间定义特定状态。每个关键帧还可以具有自己的内插器，以控制前一个关键帧时间与该关键帧时间之间的时间间隔内的动画行为。要实例化一个Keyframe对象，必须使用工厂方法之一,如ofInt（），ofFloat（）或ofObject（）来获取适当类型的Keyframe。然后，调用ofKeyframe（）工厂方法以获得PropertyValuesHolder对象。获得对象后，可以通过传递PropertyValuesHolder对象和要进行动画处理的对象来获得动画。以下代码片段演示了如何执行此操作： 1Keyframe kf0 = Keyframe.ofFloat(0f, 0f);2Keyframe kf1 = Keyframe.ofFloat(.5f, 360f);3Keyframe kf2 = Keyframe.ofFloat(1f, 0f);4PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(\"rotation\", kf0, kf1, kf2);5ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation);6rotationAnim.setDuration(5000); ViewPropertyAnimatorViewPropertyAnimator提供了一种简单的方法，可以使用单个基础Animator对象对视图的多个属性进行并行动画处理。它的行为很像ObjectAnimator，因为它修改了视图属性的实际值，但是在一次为多个属性设置动画时效率更高。此外，使用ViewPropertyAnimator的代码更加简洁明了，更易于阅读. 多ObjectAnmator对象1ObjectAnimator animX = ObjectAnimator.ofFloat(myView, \"x\", 50f);2ObjectAnimator animY = ObjectAnimator.ofFloat(myView, \"y\", 100f);3AnimatorSet animSetXY = new AnimatorSet();4animSetXY.playTogether(animX, animY);5animSetXY.start(); 单ObjectAnimator1PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(\"x\", 50f);2PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(\"y\", 100f);3ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvhY).start(); ViewPropertyAnimator1myView.animate().x(50f).y(100f);","text":"属性动画 主要概念 Duration Time interpolation Repeat count and behavior Animator sets Frame refresh delay ValueAnimator执行过程 ValueAnimator对象跟踪动画的时间安排，例如动画运行了多长时间，以及正在设置动画的属性的当前值。ValueAnimator封装了一个TimeInterpolator和TypeEvaluator，后者定义了动画插值，而TypeEvaluator定义了如何为动画属性计算值。要开启动画，创建一个ValueAnimator并为其提供要设置动画的属性的开始和结束值，以及动画的持续时间。当您调用start（）时，动画开始。在整个动画过程中，ValueAnimator会根据动画的持续时间和经过的时间来计算0到1之间的经过分数（fraction）。逝去的分数表示动画已完成的时间百分比，0表示0％，1表示100％。当ValueAnimator完成计算经过的分数时，它将调用当前设置的TimeInterpolator，以计算插值分数（按照一定公式转化fraction）。计算插值的分数时，ValueAnimator调用适当的TypeEvaluator，以基于插值的分数，动画的起始值和结束值来计算要设置动画的对应属性值。 使用 基本使用 1ValueAnimator animation = ValueAnimator.ofFloat(0f, 100f);2animation.setDuration(1000);3animation.start(); 还可以通过执行以下操作来指定要制作动画的自定义类型 1ValueAnimator animation = ValueAnimator.ofObject(new MyTypeEvaluator(), startPropertyValue, endPropertyValue);2animation.setDuration(1000);3animation.start(); 通过将AnimatorUpdateListener添加到ValueAnimator对象来使用动画的值，如以下代码所示： 1animation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;2 @Override3 public void onAnimationUpdate(ValueAnimator updatedAnimation) &#123;4 // You can use the animated value in a property that uses the5 // same type as the animation. In this case, you can use the6 // float value in the translationX property.7 float animatedValue = (float)updatedAnimation.getAnimatedValue();8 textView.setTranslationX(animatedValue);9 &#125;10 &#125;); ObjectAnimator使用 1ObjectAnimator animation = ObjectAnimator.ofFloat(textView, \"translationX\", 100f);2animation.setDuration(1000);3animation.start(); 针对执行动画的属性在对应对象中必须要包含对应属性的set与get方法 AnimatorSet组合多个动画AnimatorSet组合多个Animator，并与许嵌套AnimatorSet，如下代码所示： 1AnimatorSet bouncer = new AnimatorSet();2bouncer.play(bounceAnim).before(squashAnim1);3bouncer.play(squashAnim1).with(squashAnim2);4bouncer.play(squashAnim1).with(stretchAnim1);5bouncer.play(squashAnim1).with(stretchAnim2);6bouncer.play(bounceBackAnim).after(stretchAnim2);7ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, \"alpha\", 1f, 0f);8fadeAnim.setDuration(250);9AnimatorSet animatorSet = new AnimatorSet();10animatorSet.play(bouncer).before(fadeAnim);11animatorSet.start(); 上述代码片段含义即： Plays bounceAnim. Plays squashAnim1, squashAnim2, stretchAnim1, and stretchAnim2 at the same time. Plays bounceBackAnim. Plays fadeAnim. 常用监听器不细述，具体使用时查看即可 对ViewGroup对象的布局更改进行动画处理(LayoutTransition)使用LayoutTransition类在ViewGroup中为布局更改动画。将视图添加到视图组中或从视图组中删除视图时，或者使用VISIBLE，INVISIBLE或GONE调用视图的setVisibility（）方法时，ViewGroup中的视图都会经过显示和消失的动画。添加或删除视图时，ViewGroup中的其余视图也可以设置为新位置的动画。您可以通过调用setAnimator（）并使用以下LayoutTransition常量之一传入Animator对象，来在LayoutTransition对象中定义以下动画： APPEARING-标记，指示在容器中显示的项目上运行的动画。 CHANGE_APPEARING-一个标志，指示在由于新项目出现在容器中而发生变化的项目上运行的动画。 DISAPPEARING-一个标志，指示在从容器中消失的项目上运行的动画。 CHANGE_DISAPPEARING-一个标志，指示在由于容器中某个项目消失而发生变化的项目上运行的动画。 您可以为这四种类型的事件定义自己的自定义动画，以自定义布局过渡的外观，或者只是告诉动画系统使用默认动画。如何在XML中为ViewGroups启用默认布局转换。您唯一需要做的就是将ViewGroup的android：animateLayoutchanges属性设置为true。例如 1&lt;LinearLayout2 android:orientation=\"vertical\"3 android:layout_width=\"wrap_content\"4 android:layout_height=\"match_parent\"5 android:id=\"@+id/verticalContainer\"6 android:animateLayoutChanges=\"true\" /&gt; 将此属性设置为true会自动为从ViewGroup添加或删除的View以及ViewGroup中的其余View设置动画。 StateListAnimator先预先进行xml定义 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;3 &lt;!-- the pressed state; increase x and y size to 150% --&gt;4 &lt;item android:state_pressed=\"true\"&gt;5 &lt;set&gt;6 &lt;objectAnimator android:propertyName=\"scaleX\"7 android:duration=\"@android:integer/config_shortAnimTime\"8 android:valueTo=\"1.5\"9 android:valueType=\"floatType\"/&gt;10 &lt;objectAnimator android:propertyName=\"scaleY\"11 android:duration=\"@android:integer/config_shortAnimTime\"12 android:valueTo=\"1.5\"13 android:valueType=\"floatType\"/&gt;14 &lt;/set&gt;15 &lt;/item&gt;16 &lt;!-- the default, non-pressed state; set x and y size to 100% --&gt;17 &lt;item android:state_pressed=\"false\"&gt;18 &lt;set&gt;19 &lt;objectAnimator android:propertyName=\"scaleX\"20 android:duration=\"@android:integer/config_shortAnimTime\"21 android:valueTo=\"1\"22 android:valueType=\"floatType\"/&gt;23 &lt;objectAnimator android:propertyName=\"scaleY\"24 android:duration=\"@android:integer/config_shortAnimTime\"25 android:valueTo=\"1\"26 android:valueType=\"floatType\"/&gt;27 &lt;/set&gt;28 &lt;/item&gt;29&lt;/selector&gt; 绑定到相对应控件上 1&lt;Button android:stateListAnimator=\"@xml/animate_scale\"2 ... /&gt; 或者是通过设置AnimatorInflater.loadStateListAnimator（）方法，然后使用View.setStateListAnimator（）方法将动画分配给您的视图；或者，可以使用AnimatedStateListDrawable在状态更改之间播放可绘制的动画，而不是为视图的动画设置动画。默认情况下，Android 5.0中的某些系统小部件使用这些动画。下面的示例演示如何将AnimatedStateListDrawable定义为XML资源： 1&lt;!-- res/drawable/myanimstatedrawable.xml --&gt;2&lt;animated-selector3 xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;45 &lt;!-- provide a different drawable for each state--&gt;6 &lt;item android:id=\"@+id/pressed\" android:drawable=\"@drawable/drawableP\"7 android:state_pressed=\"true\"/&gt;8 &lt;item android:id=\"@+id/focused\" android:drawable=\"@drawable/drawableF\"9 android:state_focused=\"true\"/&gt;10 &lt;item android:id=\"@id/default\"11 android:drawable=\"@drawable/drawableD\"/&gt;1213 &lt;!-- specify a transition --&gt;14 &lt;transition android:fromId=\"@+id/default\" android:toId=\"@+id/pressed\"&gt;15 &lt;animation-list&gt;16 &lt;item android:duration=\"15\" android:drawable=\"@drawable/dt1\"/&gt;17 &lt;item android:duration=\"15\" android:drawable=\"@drawable/dt2\"/&gt;18 ...19 &lt;/animation-list&gt;20 &lt;/transition&gt;21 ...22&lt;/animated-selector&gt; TypeEvaluator Interpolators KeyFrames关键帧对象由时间/值对组成，可让您在动画的特定时间定义特定状态。每个关键帧还可以具有自己的内插器，以控制前一个关键帧时间与该关键帧时间之间的时间间隔内的动画行为。要实例化一个Keyframe对象，必须使用工厂方法之一,如ofInt（），ofFloat（）或ofObject（）来获取适当类型的Keyframe。然后，调用ofKeyframe（）工厂方法以获得PropertyValuesHolder对象。获得对象后，可以通过传递PropertyValuesHolder对象和要进行动画处理的对象来获得动画。以下代码片段演示了如何执行此操作： 1Keyframe kf0 = Keyframe.ofFloat(0f, 0f);2Keyframe kf1 = Keyframe.ofFloat(.5f, 360f);3Keyframe kf2 = Keyframe.ofFloat(1f, 0f);4PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(\"rotation\", kf0, kf1, kf2);5ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation);6rotationAnim.setDuration(5000); ViewPropertyAnimatorViewPropertyAnimator提供了一种简单的方法，可以使用单个基础Animator对象对视图的多个属性进行并行动画处理。它的行为很像ObjectAnimator，因为它修改了视图属性的实际值，但是在一次为多个属性设置动画时效率更高。此外，使用ViewPropertyAnimator的代码更加简洁明了，更易于阅读. 多ObjectAnmator对象1ObjectAnimator animX = ObjectAnimator.ofFloat(myView, \"x\", 50f);2ObjectAnimator animY = ObjectAnimator.ofFloat(myView, \"y\", 100f);3AnimatorSet animSetXY = new AnimatorSet();4animSetXY.playTogether(animX, animY);5animSetXY.start(); 单ObjectAnimator1PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(\"x\", 50f);2PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(\"y\", 100f);3ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvhY).start(); ViewPropertyAnimator1myView.animate().x(50f).y(100f);","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Animation","slug":"Animation","permalink":"http://yoursite.com/tags/Animation/"}]},{"title":"Canvas绘图坐标系与绘图坐标系","slug":"Canvas坐标系与绘图坐标系","date":"2020-01-02T07:22:29.649Z","updated":"2020-01-02T07:27:28.692Z","comments":true,"path":"2020/01/02/Canvas坐标系与绘图坐标系/","link":"","permalink":"http://yoursite.com/2020/01/02/Canvas%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%8E%E7%BB%98%E5%9B%BE%E5%9D%90%E6%A0%87%E7%B3%BB/","excerpt":"Canvas绘图中牵扯到两种坐标系：Canvas坐标系与绘图坐标系。Canvas坐标系Canvas坐标系指的是Canvas本身的坐标系，Canvas坐标系有且只有一个，且是唯一不变的，其坐标原点在View的左上角，从坐标原点向右为x轴的正半轴，从坐标原点向下为y轴的正半轴。 绘图坐标系Canvas的drawXXX方法中传入的各种坐标指的都是绘图坐标系中的坐标，而非Canvas坐标系中的坐标。默认情况下，绘图坐标系与Canvas坐标系完全重合，即初始状况下，绘图坐标系的坐标原点也在View的左上角，从原点向右为x轴正半轴，从原点向下为y轴正半轴。但不同于Canvas坐标系，绘图坐标系并不是一成不变的，可以通过调用Canvas的translate方法平移坐标系，可以通过Canvas的rotate方法旋转坐标系，还可以通过Canvas的scale方法缩放坐标系，而且需要注意的是，translate、rotate、scale的操作都是基于当前绘图坐标系的，而不是基于Canvas坐标系，一旦通过以上方法对坐标系进行了操作之后，当前绘图坐标系就变化了，以后绘图都是基于更新的绘图坐标系了。也就是说，真正对我们绘图有用的是绘图坐标系而非Canvas坐标系。 为了更好的理解绘图坐标系，请看如下的代码： 1//绘制坐标系2 private void drawAxis(Canvas canvas)&#123;3 int canvasWidth = canvas.getWidth();4 int canvasHeight = canvas.getHeight();5 paint.setStyle(Paint.Style.STROKE);6 paint.setStrokeCap(Paint.Cap.ROUND);7 paint.setStrokeWidth(6 * density);8 9 //用绿色画x轴，用蓝色画y轴10 11 //第一次绘制坐标轴12 paint.setColor(0xff00ff00);//绿色13 canvas.drawLine(0, 0, canvasWidth, 0, paint);//绘制x轴14 paint.setColor(0xff0000ff);//蓝色15 canvas.drawLine(0, 0, 0, canvasHeight, paint);//绘制y轴16 17 //对坐标系平移后，第二次绘制坐标轴18 canvas.translate(canvasWidth / 4, canvasWidth /4);//把坐标系向右下角平移19 paint.setColor(0xff00ff00);//绿色20 canvas.drawLine(0, 0, canvasWidth, 0, paint);//绘制x轴21 paint.setColor(0xff0000ff);//蓝色22 canvas.drawLine(0, 0, 0, canvasHeight, paint);//绘制y轴23 24 //再次平移坐标系并在此基础上旋转坐标系，第三次绘制坐标轴25 canvas.translate(canvasWidth / 4, canvasWidth / 4);//在上次平移的基础上再把坐标系向右下角平移26 canvas.rotate(30);//基于当前绘图坐标系的原点旋转坐标系27 paint.setColor(0xff00ff00);//绿色28 canvas.drawLine(0, 0, canvasWidth, 0, paint);//绘制x轴29 paint.setColor(0xff0000ff);//蓝色30 canvas.drawLine(0, 0, 0, canvasHeight, paint);//绘制y轴31 &#125; 第一次绘制绘图坐标系时，绘图坐标系默认情况下和Canvas坐标系重合，所以绘制出的坐标系紧贴View的上侧和左侧；第二次首先将坐标轴向右下角平移了一段距离，然后绘制出的坐标系也就整体向右下角平移了；第三次再次向右下角平移，并旋转了30度，图上倾斜的坐标系即最后的绘图坐标系","text":"Canvas绘图中牵扯到两种坐标系：Canvas坐标系与绘图坐标系。Canvas坐标系Canvas坐标系指的是Canvas本身的坐标系，Canvas坐标系有且只有一个，且是唯一不变的，其坐标原点在View的左上角，从坐标原点向右为x轴的正半轴，从坐标原点向下为y轴的正半轴。 绘图坐标系Canvas的drawXXX方法中传入的各种坐标指的都是绘图坐标系中的坐标，而非Canvas坐标系中的坐标。默认情况下，绘图坐标系与Canvas坐标系完全重合，即初始状况下，绘图坐标系的坐标原点也在View的左上角，从原点向右为x轴正半轴，从原点向下为y轴正半轴。但不同于Canvas坐标系，绘图坐标系并不是一成不变的，可以通过调用Canvas的translate方法平移坐标系，可以通过Canvas的rotate方法旋转坐标系，还可以通过Canvas的scale方法缩放坐标系，而且需要注意的是，translate、rotate、scale的操作都是基于当前绘图坐标系的，而不是基于Canvas坐标系，一旦通过以上方法对坐标系进行了操作之后，当前绘图坐标系就变化了，以后绘图都是基于更新的绘图坐标系了。也就是说，真正对我们绘图有用的是绘图坐标系而非Canvas坐标系。 为了更好的理解绘图坐标系，请看如下的代码： 1//绘制坐标系2 private void drawAxis(Canvas canvas)&#123;3 int canvasWidth = canvas.getWidth();4 int canvasHeight = canvas.getHeight();5 paint.setStyle(Paint.Style.STROKE);6 paint.setStrokeCap(Paint.Cap.ROUND);7 paint.setStrokeWidth(6 * density);8 9 //用绿色画x轴，用蓝色画y轴10 11 //第一次绘制坐标轴12 paint.setColor(0xff00ff00);//绿色13 canvas.drawLine(0, 0, canvasWidth, 0, paint);//绘制x轴14 paint.setColor(0xff0000ff);//蓝色15 canvas.drawLine(0, 0, 0, canvasHeight, paint);//绘制y轴16 17 //对坐标系平移后，第二次绘制坐标轴18 canvas.translate(canvasWidth / 4, canvasWidth /4);//把坐标系向右下角平移19 paint.setColor(0xff00ff00);//绿色20 canvas.drawLine(0, 0, canvasWidth, 0, paint);//绘制x轴21 paint.setColor(0xff0000ff);//蓝色22 canvas.drawLine(0, 0, 0, canvasHeight, paint);//绘制y轴23 24 //再次平移坐标系并在此基础上旋转坐标系，第三次绘制坐标轴25 canvas.translate(canvasWidth / 4, canvasWidth / 4);//在上次平移的基础上再把坐标系向右下角平移26 canvas.rotate(30);//基于当前绘图坐标系的原点旋转坐标系27 paint.setColor(0xff00ff00);//绿色28 canvas.drawLine(0, 0, canvasWidth, 0, paint);//绘制x轴29 paint.setColor(0xff0000ff);//蓝色30 canvas.drawLine(0, 0, 0, canvasHeight, paint);//绘制y轴31 &#125; 第一次绘制绘图坐标系时，绘图坐标系默认情况下和Canvas坐标系重合，所以绘制出的坐标系紧贴View的上侧和左侧；第二次首先将坐标轴向右下角平移了一段距离，然后绘制出的坐标系也就整体向右下角平移了；第三次再次向右下角平移，并旋转了30度，图上倾斜的坐标系即最后的绘图坐标系","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Fragment懒加载","slug":"Fragment懒加载","date":"2019-12-13T09:43:29.195Z","updated":"2019-12-13T09:46:16.652Z","comments":true,"path":"2019/12/13/Fragment懒加载/","link":"","permalink":"http://yoursite.com/2019/12/13/Fragment%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"Fragment的懒加载的一般实现方案:1public abstract class LazyFragment extends Fragment &#123;2 /**3 * 标记已加载完成，保证懒加载只能加载一次4 */5 private boolean hasLoaded = false;6 /**7 * 标记Fragment是否已经onCreate8 */9 private boolean isCreated = false;10 /**11 * 界面对于用户是否可见12 */13 private boolean isVisibleToUser = false;14 private View view;15 16 public LazyFragment() &#123;17 // Required empty public constructor18 &#125;19 20 21 @Override22 public View onCreateView(LayoutInflater inflater, ViewGroup container,23 Bundle savedInstanceState) &#123;24 init(getView(inflater, getLayoutId(), container), savedInstanceState);25 return view;26 &#125;27 28 private View getView(LayoutInflater inflater, int layoutId, ViewGroup container) &#123;29 return inflater.inflate(layoutId, container, false);30 &#125;31 32 33 public void init(View view, Bundle savedInstanceState) &#123;34 isCreated = true;35 this.view = view;36 initViews(this.view,savedInstanceState);37 lazyLoad(this.view,savedInstanceState);38 &#125;39 /**40 * 监听界面是否展示给用户，实现懒加载41 * 这个方法也是网上的一些方法用的最多的一个，我的思路也是这个，不过把整体思路完善了一下42 */43 @Override44 public void setUserVisibleHint(boolean isVisibleToUser) &#123;45 Log.i(\"TAG\", \"setUserVisibleHint: \");46 //注：关键步骤47 this.isVisibleToUser = isVisibleToUser;48 lazyLoad(view, null);49 &#125;50 /**51 * 视图初始化52 */53 public abstract void initViews(View view,Bundle savedInstanceState);54 55 56 /**57 * 懒加载方法，获取数据什么的放到这边来使用，在切换到这个界面时才进行网络请求58 */59 private void lazyLoad(View view, Bundle savedInstanceState) &#123;60 61 //如果该界面不对用户显示、已经加载、fragment还没有创建，62 //三种情况任意一种，不获取数据63 if (!isVisibleToUser || hasLoaded || !isCreated) &#123;64 return;65 &#125;66 lazyInit(view, savedInstanceState);67 //注：关键步骤，确保数据只加载一次68 hasLoaded = true;69 &#125;70 71 /**72 * 子类必须实现的方法，这个方法里面的操作都是需要懒加载的73 */74 public abstract void lazyInit(View view, Bundle savedInstanceState);75 /**76 * Fragment布局77 */78 public abstract int getLayoutId();79 80 81 @Override82 public void onDestroyView() &#123;83 super.onDestroyView();84 isCreated = false;85 hasLoaded = false;86 &#125;87&#125;","text":"Fragment的懒加载的一般实现方案:1public abstract class LazyFragment extends Fragment &#123;2 /**3 * 标记已加载完成，保证懒加载只能加载一次4 */5 private boolean hasLoaded = false;6 /**7 * 标记Fragment是否已经onCreate8 */9 private boolean isCreated = false;10 /**11 * 界面对于用户是否可见12 */13 private boolean isVisibleToUser = false;14 private View view;15 16 public LazyFragment() &#123;17 // Required empty public constructor18 &#125;19 20 21 @Override22 public View onCreateView(LayoutInflater inflater, ViewGroup container,23 Bundle savedInstanceState) &#123;24 init(getView(inflater, getLayoutId(), container), savedInstanceState);25 return view;26 &#125;27 28 private View getView(LayoutInflater inflater, int layoutId, ViewGroup container) &#123;29 return inflater.inflate(layoutId, container, false);30 &#125;31 32 33 public void init(View view, Bundle savedInstanceState) &#123;34 isCreated = true;35 this.view = view;36 initViews(this.view,savedInstanceState);37 lazyLoad(this.view,savedInstanceState);38 &#125;39 /**40 * 监听界面是否展示给用户，实现懒加载41 * 这个方法也是网上的一些方法用的最多的一个，我的思路也是这个，不过把整体思路完善了一下42 */43 @Override44 public void setUserVisibleHint(boolean isVisibleToUser) &#123;45 Log.i(\"TAG\", \"setUserVisibleHint: \");46 //注：关键步骤47 this.isVisibleToUser = isVisibleToUser;48 lazyLoad(view, null);49 &#125;50 /**51 * 视图初始化52 */53 public abstract void initViews(View view,Bundle savedInstanceState);54 55 56 /**57 * 懒加载方法，获取数据什么的放到这边来使用，在切换到这个界面时才进行网络请求58 */59 private void lazyLoad(View view, Bundle savedInstanceState) &#123;60 61 //如果该界面不对用户显示、已经加载、fragment还没有创建，62 //三种情况任意一种，不获取数据63 if (!isVisibleToUser || hasLoaded || !isCreated) &#123;64 return;65 &#125;66 lazyInit(view, savedInstanceState);67 //注：关键步骤，确保数据只加载一次68 hasLoaded = true;69 &#125;70 71 /**72 * 子类必须实现的方法，这个方法里面的操作都是需要懒加载的73 */74 public abstract void lazyInit(View view, Bundle savedInstanceState);75 /**76 * Fragment布局77 */78 public abstract int getLayoutId();79 80 81 @Override82 public void onDestroyView() &#123;83 super.onDestroyView();84 isCreated = false;85 hasLoaded = false;86 &#125;87&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://yoursite.com/tags/Fragment/"}]},{"title":"Android动画记录","slug":"Android动画","date":"2019-12-11T05:07:31.295Z","updated":"2019-12-18T06:44:11.016Z","comments":true,"path":"2019/12/11/Android动画/","link":"","permalink":"http://yoursite.com/2019/12/11/Android%E5%8A%A8%E7%94%BB/","excerpt":"可以通过动画添加视觉提示，向用户通知应用中的动态。当界面状态发生改变时（例如有新内容加载或有新操作可用时），动画尤其有用。动画还为应用增加了优美的外观，使其拥有更高品质的外观和风格.Android 根据您需要的动画类型提供不同的动画 API 帧动画将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果 实现案例1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;3 &lt;item4 android:drawable=\"@drawable/a_0\"5 android:duration=\"100\" /&gt;6 &lt;item7 android:drawable=\"@drawable/a_1\"8 android:duration=\"100\" /&gt;9 &lt;item10 android:drawable=\"@drawable/a_2\"11 android:duration=\"100\" /&gt;12&lt;/animation-list&gt;1314protected void onCreate(@Nullable Bundle savedInstanceState) &#123;15 super.onCreate(savedInstanceState);16 setContentView(R.layout.activity_frame_animation);17 ImageView animationImg1 = (ImageView) findViewById(R.id.animation1);18 animationImg1.setImageResource(R.drawable.frame_anim1);19 AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable();20 animationDrawable1.start();21 &#125; 补间动画 alpha 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:duration=\"1000\"4 android:fromAlpha=\"1.0\"5 android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"6 android:toAlpha=\"0.0\" /&gt; translate scale 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;scale xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:duration=\"1000\"4 android:fromXScale=\"0.0\"5 android:fromYScale=\"0.0\"6 android:pivotX=\"50%\"7 android:pivotY=\"50%\"8 android:toXScale=\"1.0\"9 android:toYScale=\"1.0\"/&gt; rotate 然后在Activity中 1Animation animation = AnimationUtils.loadAnimation(mContext, R.anim.alpha_anim);2img = (ImageView) findViewById(R.id.img);3img.startAnimation(animation);","text":"可以通过动画添加视觉提示，向用户通知应用中的动态。当界面状态发生改变时（例如有新内容加载或有新操作可用时），动画尤其有用。动画还为应用增加了优美的外观，使其拥有更高品质的外观和风格.Android 根据您需要的动画类型提供不同的动画 API 帧动画将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果 实现案例1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;3 &lt;item4 android:drawable=\"@drawable/a_0\"5 android:duration=\"100\" /&gt;6 &lt;item7 android:drawable=\"@drawable/a_1\"8 android:duration=\"100\" /&gt;9 &lt;item10 android:drawable=\"@drawable/a_2\"11 android:duration=\"100\" /&gt;12&lt;/animation-list&gt;1314protected void onCreate(@Nullable Bundle savedInstanceState) &#123;15 super.onCreate(savedInstanceState);16 setContentView(R.layout.activity_frame_animation);17 ImageView animationImg1 = (ImageView) findViewById(R.id.animation1);18 animationImg1.setImageResource(R.drawable.frame_anim1);19 AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable();20 animationDrawable1.start();21 &#125; 补间动画 alpha 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:duration=\"1000\"4 android:fromAlpha=\"1.0\"5 android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"6 android:toAlpha=\"0.0\" /&gt; translate scale 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;scale xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:duration=\"1000\"4 android:fromXScale=\"0.0\"5 android:fromYScale=\"0.0\"6 android:pivotX=\"50%\"7 android:pivotY=\"50%\"8 android:toXScale=\"1.0\"9 android:toYScale=\"1.0\"/&gt; rotate 然后在Activity中 1Animation animation = AnimationUtils.loadAnimation(mContext, R.anim.alpha_anim);2img = (ImageView) findViewById(R.id.img);3img.startAnimation(animation); 也可以将多个动画集合在一起 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:interpolator=\"@[package:]anim/interpolator_resource\"4 android:shareInterpolator=[\"true\" | \"false\"] &gt;5 &lt;alpha6 android:fromAlpha=\"float\"7 android:toAlpha=\"float\" /&gt;8 &lt;scale9 android:fromXScale=\"float\"10 android:toXScale=\"float\"11 android:fromYScale=\"float\"12 android:toYScale=\"float\"13 android:pivotX=\"float\"14 android:pivotY=\"float\" /&gt;15 &lt;translate16 android:fromXDelta=\"float\"17 android:toXDelta=\"float\"18 android:fromYDelta=\"float\"19 android:toYDelta=\"float\" /&gt;20 &lt;rotate21 android:fromDegrees=\"float\"22 android:toDegrees=\"float\"23 android:pivotX=\"float\"24 android:pivotY=\"float\" /&gt;25 &lt;set&gt;26 ...27 &lt;/set&gt;28&lt;/set&gt; 属性动画1private void RotateAnimation() &#123;2 ObjectAnimator anim = ObjectAnimator.ofFloat(myView, \"rotation\", 0f, 360f);3 anim.setDuration(1000);4 anim.start();5 &#125;67 private void AlpahAnimation() &#123;8 ObjectAnimator anim = ObjectAnimator.ofFloat(myView, \"alpha\", 1.0f, 0.8f, 0.6f, 0.4f, 0.2f, 0.0f);9 anim.setRepeatCount(-1);10 anim.setRepeatMode(ObjectAnimator.REVERSE);11 anim.setDuration(2000);12 anim.start();13 &#125; 属性动画集： 1 ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(myView, \"alpha\", 1.0f, 0.5f, 0.8f, 1.0f);2 ObjectAnimator scaleXAnim = ObjectAnimator.ofFloat(myView, \"scaleX\", 0.0f, 1.0f);3 ObjectAnimator scaleYAnim = ObjectAnimator.ofFloat(myView, \"scaleY\", 0.0f, 2.0f);4 ObjectAnimator rotateAnim = ObjectAnimator.ofFloat(myView, \"rotation\", 0, 360);5 ObjectAnimator transXAnim = ObjectAnimator.ofFloat(myView, \"translationX\", 100, 400);6 ObjectAnimator transYAnim = ObjectAnimator.ofFloat(myView, \"tranlsationY\", 100, 750);7 AnimatorSet set = new AnimatorSet();8 set.playTogether(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);9// set.playSequentially(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);10 set.setDuration(3000);11 set.start(); Note:TypeEvaluator 决定了动画如何从初始值过渡到结束值。TimeInterpolator 决定了动画从初始值过渡到结束值的节奏 自定义TypeEvaluator 1public class PointSinEvaluator implements TypeEvaluator &#123;23 @Override4 public Object evaluate(float fraction, Object startValue, Object endValue) &#123;5 Point startPoint = (Point) startValue;6 Point endPoint = (Point) endValue;7 float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());89 float y = (float) (Math.sin(x * Math.PI / 180) * 100) + endPoint.getY() / 2;10 Point point = new Point(x, y);11 return point;12 &#125;13&#125;14，第一个参数fraction 代表当前动画完成的百分比，这个值是如何变化的后面还会提到；第二个和第三个参数代表动画的初始值和结束值1516Point startP = new Point(RADIUS, RADIUS);//初始值（起点）17 Point endP = new Point(getWidth() - RADIUS, getHeight() - RADIUS);//结束值（终点）18 final ValueAnimator valueAnimator = ValueAnimator.ofObject(new PointSinEvaluator(), startP, endP);19 valueAnimator.setRepeatCount(-1);20 valueAnimator.setRepeatMode(ValueAnimator.REVERSE);21 valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;22 @Override23 public void onAnimationUpdate(ValueAnimator animation) &#123;24 currentPoint = (Point) animation.getAnimatedValue();25 postInvalidate();26 &#125;27 &#125;); 属性动画当然也可以使用xml文件的方式实现 1&lt;set android:ordering=\"sequentially\"&gt;2 &lt;set&gt;3 &lt;objectAnimator4 android:propertyName=\"x\"5 android:duration=\"500\"6 android:valueTo=\"400\"7 android:valueType=\"intType\"/&gt;8 &lt;objectAnimator9 android:propertyName=\"y\"10 android:duration=\"500\"11 android:valueTo=\"300\"12 android:valueType=\"intType\"/&gt;13 &lt;/set&gt;14 &lt;objectAnimator15 android:propertyName=\"alpha\"16 android:duration=\"500\"17 android:valueTo=\"1f\"/&gt;18&lt;/set&gt;1920AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,21 R.anim.property_animator);22set.setTarget(myObject);23set.start();","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Animation","slug":"Animation","permalink":"http://yoursite.com/tags/Animation/"}]},{"title":"Java线程池记录","slug":"Java线程池","date":"2019-12-10T05:51:19.294Z","updated":"2019-12-12T09:18:16.105Z","comments":true,"path":"2019/12/10/Java线程池/","link":"","permalink":"http://yoursite.com/2019/12/10/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"构造一个线程池为什么需要几个参数？如果避免线程池出现OOM？Runnable和Callable的区别是什么？ Thread/Runnable/Callable 继承Thread1class MyThread extend Thread()&#123;2 @Override3 public void run() &#123;4 super.run();5 Log.i(Thread.currentThread().getId());6 &#125;7&#125;8new MyThread().start(); Runnable1class MyThread implements Runnable&#123;2 @Override3 public void run() &#123;4 Log.i(\"MyThread\", Thread.currentThread().getName());5 &#125;6&#125;7MyThreaed myThread = new MyThread();8new Thread(myThread).start(); Callable 的 call() 方法可以返回值和抛出异常,Callable 可以返回装载有计算结果的 Future 对象。 比较结论 Callable 接口下的方法是 call()，Runnable 接口的方法是 run()； Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的； call() 方法可以抛出异常，run()方法不可以的；运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果 ThreadPoolExecutor1public ThreadPoolExecutor(int corePoolSize,2 int maximumPoolSize,3 long keepAliveTime,4 TimeUnit unit,5 BlockingQueue&lt;Runnable&gt; workQueue) &#123;6 this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,7 Executors.defaultThreadFactory(), defaultHandler);8&#125; corePoolSize，线程池中核心线程的数量，默认情况下，即使核心线程没有任务在执行它也存在的，我们固定一定数量的核心线程且它一直存活这样就避免了一般情况下CPU创建和销毁线程带来的开销。我们如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程就会有超时策略，这个时间由keepAliveTime来设定，即keepAliveTime时间内如果核心线程没有回应则该线程就会被终止。allowCoreThreadTimeOut默认为false，核心线程没有超时时间。 maximumPoolSize，线程池中的最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数=核心线程+非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。 keepAliveTime，非核心线程的超时时长，当执行时间超过这个时间时，非核心线程就会被回收。当allowCoreThreadTimeOut设置为true时，此属性也作用在核心线程上。 unit，枚举时间单位，TimeUnit。 workQueue，线程池中的任务队列，我们提交给线程池的runnable会被存储在这个对象上。 线程池的分配遵循这样的规则： 当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务； 如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行； 如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务； 如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且ThreadPoolExecutor会调用RejectedtionHandler的rejectedExecution方法来通知调用者。","text":"构造一个线程池为什么需要几个参数？如果避免线程池出现OOM？Runnable和Callable的区别是什么？ Thread/Runnable/Callable 继承Thread1class MyThread extend Thread()&#123;2 @Override3 public void run() &#123;4 super.run();5 Log.i(Thread.currentThread().getId());6 &#125;7&#125;8new MyThread().start(); Runnable1class MyThread implements Runnable&#123;2 @Override3 public void run() &#123;4 Log.i(\"MyThread\", Thread.currentThread().getName());5 &#125;6&#125;7MyThreaed myThread = new MyThread();8new Thread(myThread).start(); Callable 的 call() 方法可以返回值和抛出异常,Callable 可以返回装载有计算结果的 Future 对象。 比较结论 Callable 接口下的方法是 call()，Runnable 接口的方法是 run()； Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的； call() 方法可以抛出异常，run()方法不可以的；运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果 ThreadPoolExecutor1public ThreadPoolExecutor(int corePoolSize,2 int maximumPoolSize,3 long keepAliveTime,4 TimeUnit unit,5 BlockingQueue&lt;Runnable&gt; workQueue) &#123;6 this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,7 Executors.defaultThreadFactory(), defaultHandler);8&#125; corePoolSize，线程池中核心线程的数量，默认情况下，即使核心线程没有任务在执行它也存在的，我们固定一定数量的核心线程且它一直存活这样就避免了一般情况下CPU创建和销毁线程带来的开销。我们如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程就会有超时策略，这个时间由keepAliveTime来设定，即keepAliveTime时间内如果核心线程没有回应则该线程就会被终止。allowCoreThreadTimeOut默认为false，核心线程没有超时时间。 maximumPoolSize，线程池中的最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数=核心线程+非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。 keepAliveTime，非核心线程的超时时长，当执行时间超过这个时间时，非核心线程就会被回收。当allowCoreThreadTimeOut设置为true时，此属性也作用在核心线程上。 unit，枚举时间单位，TimeUnit。 workQueue，线程池中的任务队列，我们提交给线程池的runnable会被存储在这个对象上。 线程池的分配遵循这样的规则： 当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务； 如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行； 如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务； 如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且ThreadPoolExecutor会调用RejectedtionHandler的rejectedExecution方法来通知调用者。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Thread","slug":"Thread","permalink":"http://yoursite.com/tags/Thread/"}]}]}