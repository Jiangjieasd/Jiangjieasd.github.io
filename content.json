{"meta":{"title":"Harry.Jiang","subtitle":"无欲速，无见小利。欲速则不达，见小利则大事不成","description":"砥砺前行","author":"Harry","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Java线程池记录","slug":"Java线程池","date":"2019-12-10T05:51:19.294Z","updated":"2019-12-10T06:13:34.528Z","comments":true,"path":"2019/12/10/Java线程池/","link":"","permalink":"http://yoursite.com/2019/12/10/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"Thread/Runnable/Callable 继承Thread1class MyThread extend Thread()&#123;2 @Override3 public void run() &#123;4 super.run();5 Log.i(Thread.currentThread().getId());6 &#125;7&#125;8new MyThread().start(); Runnable12&lt;!--more--&gt;34class MyThread implements Runnable&#123;5 @Override6 public void run() &#123;7 Log.i(&quot;MyThread&quot;, Thread.currentThread().getName());8 &#125;9&#125;10MyThreaed myThread &#x3D; new MyThread();11new Thread(myThread).start(); Callable 的 call() 方法可以返回值和抛出异常,Callable 可以返回装载有计算结果的 Future 对象。 比较结论 Callable 接口下的方法是 call()，Runnable 接口的方法是 run()； Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的； call() 方法可以抛出异常，run()方法不可以的；运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果 ThreadPoolExecutor1public ThreadPoolExecutor(int corePoolSize,2 int maximumPoolSize,3 long keepAliveTime,4 TimeUnit unit,5 BlockingQueue&lt;Runnable&gt; workQueue) &#123;6 this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,7 Executors.defaultThreadFactory(), defaultHandler);8&#125; corePoolSize，线程池中核心线程的数量，默认情况下，即使核心线程没有任务在执行它也存在的，我们固定一定数量的核心线程且它一直存活这样就避免了一般情况下CPU创建和销毁线程带来的开销。我们如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程就会有超时策略，这个时间由keepAliveTime来设定，即keepAliveTime时间内如果核心线程没有回应则该线程就会被终止。allowCoreThreadTimeOut默认为false，核心线程没有超时时间。 maximumPoolSize，线程池中的最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数=核心线程+非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。 keepAliveTime，非核心线程的超时时长，当执行时间超过这个时间时，非核心线程就会被回收。当allowCoreThreadTimeOut设置为true时，此属性也作用在核心线程上。 unit，枚举时间单位，TimeUnit。 workQueue，线程池中的任务队列，我们提交给线程池的runnable会被存储在这个对象上。 线程池的分配遵循这样的规则： 当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务； 如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行； 如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务； 如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且ThreadPoolExecutor会调用RejectedtionHandler的rejectedExecution方法来通知调用者。","categories":[],"tags":[]}]}