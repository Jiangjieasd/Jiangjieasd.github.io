{"meta":{"title":"编程、悟道","subtitle":"无欲速，无见小利。欲速则不达，见小利则大事不成","description":"砥砺前行","author":"Harry","url":"http://yoursite.com","root":"/"},"pages":[{"title":"尝试了解一下哥吧^_^","date":"2019-12-12T02:46:55.000Z","updated":"2019-12-12T08:10:23.583Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"江杰（Harry.Jiang） 我什么都能干 除了生孩子 甲戌年甲戌月己巳日生 现居：浙江-杭州 本人邮箱jiangjiejobs@163.com，欢迎交流讨论 菜鸟Github，不常更新 无聊者知乎"}],"posts":[{"title":"Android动画记录","slug":"Android动画","date":"2019-12-11T05:07:31.295Z","updated":"2019-12-12T08:11:03.389Z","comments":true,"path":"2019/12/11/Android动画/","link":"","permalink":"http://yoursite.com/2019/12/11/Android%E5%8A%A8%E7%94%BB/","excerpt":"可以通过动画添加视觉提示，向用户通知应用中的动态。当界面状态发生改变时（例如有新内容加载或有新操作可用时），动画尤其有用。动画还为应用增加了优美的外观，使其拥有更高品质的外观和风格.Android 根据您需要的动画类型提供不同的动画 API 帧动画将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果 实现案例1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;3 &lt;item4 android:drawable=\"@drawable/a_0\"5 android:duration=\"100\" /&gt;6 &lt;item7 android:drawable=\"@drawable/a_1\"8 android:duration=\"100\" /&gt;9 &lt;item10 android:drawable=\"@drawable/a_2\"11 android:duration=\"100\" /&gt;12&lt;/animation-list&gt;1314protected void onCreate(@Nullable Bundle savedInstanceState) &#123;15 super.onCreate(savedInstanceState);16 setContentView(R.layout.activity_frame_animation);17 ImageView animationImg1 = (ImageView) findViewById(R.id.animation1);18 animationImg1.setImageResource(R.drawable.frame_anim1);19 AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable();20 animationDrawable1.start();21 &#125; 补间动画 alpha 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:duration=\"1000\"4 android:fromAlpha=\"1.0\"5 android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"6 android:toAlpha=\"0.0\" /&gt; translate scale 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;scale xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:duration=\"1000\"4 android:fromXScale=\"0.0\"5 android:fromYScale=\"0.0\"6 android:pivotX=\"50%\"7 android:pivotY=\"50%\"8 android:toXScale=\"1.0\"9 android:toYScale=\"1.0\"/&gt; rotate 然后在Activity中 1Animation animation = AnimationUtils.loadAnimation(mContext, R.anim.alpha_anim);2img = (ImageView) findViewById(R.id.img);3img.startAnimation(animation);","text":"可以通过动画添加视觉提示，向用户通知应用中的动态。当界面状态发生改变时（例如有新内容加载或有新操作可用时），动画尤其有用。动画还为应用增加了优美的外观，使其拥有更高品质的外观和风格.Android 根据您需要的动画类型提供不同的动画 API 帧动画将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果 实现案例1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;3 &lt;item4 android:drawable=\"@drawable/a_0\"5 android:duration=\"100\" /&gt;6 &lt;item7 android:drawable=\"@drawable/a_1\"8 android:duration=\"100\" /&gt;9 &lt;item10 android:drawable=\"@drawable/a_2\"11 android:duration=\"100\" /&gt;12&lt;/animation-list&gt;1314protected void onCreate(@Nullable Bundle savedInstanceState) &#123;15 super.onCreate(savedInstanceState);16 setContentView(R.layout.activity_frame_animation);17 ImageView animationImg1 = (ImageView) findViewById(R.id.animation1);18 animationImg1.setImageResource(R.drawable.frame_anim1);19 AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable();20 animationDrawable1.start();21 &#125; 补间动画 alpha 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:duration=\"1000\"4 android:fromAlpha=\"1.0\"5 android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"6 android:toAlpha=\"0.0\" /&gt; translate scale 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;scale xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:duration=\"1000\"4 android:fromXScale=\"0.0\"5 android:fromYScale=\"0.0\"6 android:pivotX=\"50%\"7 android:pivotY=\"50%\"8 android:toXScale=\"1.0\"9 android:toYScale=\"1.0\"/&gt; rotate 然后在Activity中 1Animation animation = AnimationUtils.loadAnimation(mContext, R.anim.alpha_anim);2img = (ImageView) findViewById(R.id.img);3img.startAnimation(animation); 也可以将多个动画集合在一起 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:interpolator=\"@[package:]anim/interpolator_resource\"4 android:shareInterpolator=[\"true\" | \"false\"] &gt;5 &lt;alpha6 android:fromAlpha=\"float\"7 android:toAlpha=\"float\" /&gt;8 &lt;scale9 android:fromXScale=\"float\"10 android:toXScale=\"float\"11 android:fromYScale=\"float\"12 android:toYScale=\"float\"13 android:pivotX=\"float\"14 android:pivotY=\"float\" /&gt;15 &lt;translate16 android:fromXDelta=\"float\"17 android:toXDelta=\"float\"18 android:fromYDelta=\"float\"19 android:toYDelta=\"float\" /&gt;20 &lt;rotate21 android:fromDegrees=\"float\"22 android:toDegrees=\"float\"23 android:pivotX=\"float\"24 android:pivotY=\"float\" /&gt;25 &lt;set&gt;26 ...27 &lt;/set&gt;28&lt;/set&gt; 属性动画1private void RotateAnimation() &#123;2 ObjectAnimator anim = ObjectAnimator.ofFloat(myView, \"rotation\", 0f, 360f);3 anim.setDuration(1000);4 anim.start();5 &#125;67 private void AlpahAnimation() &#123;8 ObjectAnimator anim = ObjectAnimator.ofFloat(myView, \"alpha\", 1.0f, 0.8f, 0.6f, 0.4f, 0.2f, 0.0f);9 anim.setRepeatCount(-1);10 anim.setRepeatMode(ObjectAnimator.REVERSE);11 anim.setDuration(2000);12 anim.start();13 &#125; 属性动画集： 1 ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(myView, \"alpha\", 1.0f, 0.5f, 0.8f, 1.0f);2 ObjectAnimator scaleXAnim = ObjectAnimator.ofFloat(myView, \"scaleX\", 0.0f, 1.0f);3 ObjectAnimator scaleYAnim = ObjectAnimator.ofFloat(myView, \"scaleY\", 0.0f, 2.0f);4 ObjectAnimator rotateAnim = ObjectAnimator.ofFloat(myView, \"rotation\", 0, 360);5 ObjectAnimator transXAnim = ObjectAnimator.ofFloat(myView, \"translationX\", 100, 400);6 ObjectAnimator transYAnim = ObjectAnimator.ofFloat(myView, \"tranlsationY\", 100, 750);7 AnimatorSet set = new AnimatorSet();8 set.playTogether(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);9// set.playSequentially(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);10 set.setDuration(3000);11 set.start(); Note:TypeEvaluator 决定了动画如何从初始值过渡到结束值。TimeInterpolator 决定了动画从初始值过渡到结束值的节奏 自定义TypeEvaluator 1public class PointSinEvaluator implements TypeEvaluator &#123;23 @Override4 public Object evaluate(float fraction, Object startValue, Object endValue) &#123;5 Point startPoint = (Point) startValue;6 Point endPoint = (Point) endValue;7 float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());89 float y = (float) (Math.sin(x * Math.PI / 180) * 100) + endPoint.getY() / 2;10 Point point = new Point(x, y);11 return point;12 &#125;13&#125;14，第一个参数fraction 代表当前动画完成的百分比，这个值是如何变化的后面还会提到；第二个和第三个参数代表动画的初始值和结束值1516Point startP = new Point(RADIUS, RADIUS);//初始值（起点）17 Point endP = new Point(getWidth() - RADIUS, getHeight() - RADIUS);//结束值（终点）18 final ValueAnimator valueAnimator = ValueAnimator.ofObject(new PointSinEvaluator(), startP, endP);19 valueAnimator.setRepeatCount(-1);20 valueAnimator.setRepeatMode(ValueAnimator.REVERSE);21 valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;22 @Override23 public void onAnimationUpdate(ValueAnimator animation) &#123;24 currentPoint = (Point) animation.getAnimatedValue();25 postInvalidate();26 &#125;27 &#125;); 属性动画当然也可以使用xml文件的方式实现 1&lt;set android:ordering=\"sequentially\"&gt;2 &lt;set&gt;3 &lt;objectAnimator4 android:propertyName=\"x\"5 android:duration=\"500\"6 android:valueTo=\"400\"7 android:valueType=\"intType\"/&gt;8 &lt;objectAnimator9 android:propertyName=\"y\"10 android:duration=\"500\"11 android:valueTo=\"300\"12 android:valueType=\"intType\"/&gt;13 &lt;/set&gt;14 &lt;objectAnimator15 android:propertyName=\"alpha\"16 android:duration=\"500\"17 android:valueTo=\"1f\"/&gt;18&lt;/set&gt;1920AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,21 R.anim.property_animator);22set.setTarget(myObject);23set.start();","categories":[],"tags":[{"name":"Android、Animation","slug":"Android、Animation","permalink":"http://yoursite.com/tags/Android%E3%80%81Animation/"}]},{"title":"Java线程池记录","slug":"Java线程池","date":"2019-12-10T05:51:19.294Z","updated":"2019-12-12T08:11:06.147Z","comments":true,"path":"2019/12/10/Java线程池/","link":"","permalink":"http://yoursite.com/2019/12/10/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"构造一个线程池为什么需要几个参数？如果避免线程池出现OOM？Runnable和Callable的区别是什么？ Thread/Runnable/Callable 继承Thread1class MyThread extend Thread()&#123;2 @Override3 public void run() &#123;4 super.run();5 Log.i(Thread.currentThread().getId());6 &#125;7&#125;8new MyThread().start(); Runnable1class MyThread implements Runnable&#123;2 @Override3 public void run() &#123;4 Log.i(\"MyThread\", Thread.currentThread().getName());5 &#125;6&#125;7MyThreaed myThread = new MyThread();8new Thread(myThread).start(); Callable 的 call() 方法可以返回值和抛出异常,Callable 可以返回装载有计算结果的 Future 对象。 比较结论 Callable 接口下的方法是 call()，Runnable 接口的方法是 run()； Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的； call() 方法可以抛出异常，run()方法不可以的；运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果 ThreadPoolExecutor1public ThreadPoolExecutor(int corePoolSize,2 int maximumPoolSize,3 long keepAliveTime,4 TimeUnit unit,5 BlockingQueue&lt;Runnable&gt; workQueue) &#123;6 this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,7 Executors.defaultThreadFactory(), defaultHandler);8&#125; corePoolSize，线程池中核心线程的数量，默认情况下，即使核心线程没有任务在执行它也存在的，我们固定一定数量的核心线程且它一直存活这样就避免了一般情况下CPU创建和销毁线程带来的开销。我们如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程就会有超时策略，这个时间由keepAliveTime来设定，即keepAliveTime时间内如果核心线程没有回应则该线程就会被终止。allowCoreThreadTimeOut默认为false，核心线程没有超时时间。 maximumPoolSize，线程池中的最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数=核心线程+非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。 keepAliveTime，非核心线程的超时时长，当执行时间超过这个时间时，非核心线程就会被回收。当allowCoreThreadTimeOut设置为true时，此属性也作用在核心线程上。 unit，枚举时间单位，TimeUnit。 workQueue，线程池中的任务队列，我们提交给线程池的runnable会被存储在这个对象上。 线程池的分配遵循这样的规则： 当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务； 如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行； 如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务； 如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且ThreadPoolExecutor会调用RejectedtionHandler的rejectedExecution方法来通知调用者。","text":"构造一个线程池为什么需要几个参数？如果避免线程池出现OOM？Runnable和Callable的区别是什么？ Thread/Runnable/Callable 继承Thread1class MyThread extend Thread()&#123;2 @Override3 public void run() &#123;4 super.run();5 Log.i(Thread.currentThread().getId());6 &#125;7&#125;8new MyThread().start(); Runnable1class MyThread implements Runnable&#123;2 @Override3 public void run() &#123;4 Log.i(\"MyThread\", Thread.currentThread().getName());5 &#125;6&#125;7MyThreaed myThread = new MyThread();8new Thread(myThread).start(); Callable 的 call() 方法可以返回值和抛出异常,Callable 可以返回装载有计算结果的 Future 对象。 比较结论 Callable 接口下的方法是 call()，Runnable 接口的方法是 run()； Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的； call() 方法可以抛出异常，run()方法不可以的；运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果 ThreadPoolExecutor1public ThreadPoolExecutor(int corePoolSize,2 int maximumPoolSize,3 long keepAliveTime,4 TimeUnit unit,5 BlockingQueue&lt;Runnable&gt; workQueue) &#123;6 this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,7 Executors.defaultThreadFactory(), defaultHandler);8&#125; corePoolSize，线程池中核心线程的数量，默认情况下，即使核心线程没有任务在执行它也存在的，我们固定一定数量的核心线程且它一直存活这样就避免了一般情况下CPU创建和销毁线程带来的开销。我们如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程就会有超时策略，这个时间由keepAliveTime来设定，即keepAliveTime时间内如果核心线程没有回应则该线程就会被终止。allowCoreThreadTimeOut默认为false，核心线程没有超时时间。 maximumPoolSize，线程池中的最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数=核心线程+非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。 keepAliveTime，非核心线程的超时时长，当执行时间超过这个时间时，非核心线程就会被回收。当allowCoreThreadTimeOut设置为true时，此属性也作用在核心线程上。 unit，枚举时间单位，TimeUnit。 workQueue，线程池中的任务队列，我们提交给线程池的runnable会被存储在这个对象上。 线程池的分配遵循这样的规则： 当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务； 如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行； 如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务； 如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且ThreadPoolExecutor会调用RejectedtionHandler的rejectedExecution方法来通知调用者。","categories":[],"tags":[{"name":"Java、Thread","slug":"Java、Thread","permalink":"http://yoursite.com/tags/Java%E3%80%81Thread/"}]}]}