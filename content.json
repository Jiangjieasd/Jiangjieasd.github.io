{"meta":{"title":"编程、悟道","subtitle":"无欲速，无见小利。欲速则不达，见小利则大事不成","description":"砥砺前行","author":"Harry","url":"http://yoursite.com","root":"/"},"pages":[{"title":"尝试了解一下哥吧^_^","date":"2019-12-12T02:46:55.000Z","updated":"2020-01-02T07:22:45.392Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"江杰（Harry.Jiang） 我什么都能干 除了生孩子 甲戌年甲戌月己巳日生 现居：浙江-杭州 本人邮箱jiangjiejobs@163.com，欢迎交流讨论 菜鸟Github，不常更新 无聊者知乎"}],"posts":[{"title":"Canvas绘图坐标系与绘图坐标系","slug":"Canvas坐标系与绘图坐标系","date":"2020-01-02T07:22:29.649Z","updated":"2020-01-02T07:27:28.692Z","comments":true,"path":"2020/01/02/Canvas坐标系与绘图坐标系/","link":"","permalink":"http://yoursite.com/2020/01/02/Canvas%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%8E%E7%BB%98%E5%9B%BE%E5%9D%90%E6%A0%87%E7%B3%BB/","excerpt":"Canvas绘图中牵扯到两种坐标系：Canvas坐标系与绘图坐标系。Canvas坐标系Canvas坐标系指的是Canvas本身的坐标系，Canvas坐标系有且只有一个，且是唯一不变的，其坐标原点在View的左上角，从坐标原点向右为x轴的正半轴，从坐标原点向下为y轴的正半轴。 绘图坐标系Canvas的drawXXX方法中传入的各种坐标指的都是绘图坐标系中的坐标，而非Canvas坐标系中的坐标。默认情况下，绘图坐标系与Canvas坐标系完全重合，即初始状况下，绘图坐标系的坐标原点也在View的左上角，从原点向右为x轴正半轴，从原点向下为y轴正半轴。但不同于Canvas坐标系，绘图坐标系并不是一成不变的，可以通过调用Canvas的translate方法平移坐标系，可以通过Canvas的rotate方法旋转坐标系，还可以通过Canvas的scale方法缩放坐标系，而且需要注意的是，translate、rotate、scale的操作都是基于当前绘图坐标系的，而不是基于Canvas坐标系，一旦通过以上方法对坐标系进行了操作之后，当前绘图坐标系就变化了，以后绘图都是基于更新的绘图坐标系了。也就是说，真正对我们绘图有用的是绘图坐标系而非Canvas坐标系。 为了更好的理解绘图坐标系，请看如下的代码： 1//绘制坐标系2 private void drawAxis(Canvas canvas)&#123;3 int canvasWidth = canvas.getWidth();4 int canvasHeight = canvas.getHeight();5 paint.setStyle(Paint.Style.STROKE);6 paint.setStrokeCap(Paint.Cap.ROUND);7 paint.setStrokeWidth(6 * density);8 9 //用绿色画x轴，用蓝色画y轴10 11 //第一次绘制坐标轴12 paint.setColor(0xff00ff00);//绿色13 canvas.drawLine(0, 0, canvasWidth, 0, paint);//绘制x轴14 paint.setColor(0xff0000ff);//蓝色15 canvas.drawLine(0, 0, 0, canvasHeight, paint);//绘制y轴16 17 //对坐标系平移后，第二次绘制坐标轴18 canvas.translate(canvasWidth / 4, canvasWidth /4);//把坐标系向右下角平移19 paint.setColor(0xff00ff00);//绿色20 canvas.drawLine(0, 0, canvasWidth, 0, paint);//绘制x轴21 paint.setColor(0xff0000ff);//蓝色22 canvas.drawLine(0, 0, 0, canvasHeight, paint);//绘制y轴23 24 //再次平移坐标系并在此基础上旋转坐标系，第三次绘制坐标轴25 canvas.translate(canvasWidth / 4, canvasWidth / 4);//在上次平移的基础上再把坐标系向右下角平移26 canvas.rotate(30);//基于当前绘图坐标系的原点旋转坐标系27 paint.setColor(0xff00ff00);//绿色28 canvas.drawLine(0, 0, canvasWidth, 0, paint);//绘制x轴29 paint.setColor(0xff0000ff);//蓝色30 canvas.drawLine(0, 0, 0, canvasHeight, paint);//绘制y轴31 &#125; 第一次绘制绘图坐标系时，绘图坐标系默认情况下和Canvas坐标系重合，所以绘制出的坐标系紧贴View的上侧和左侧；第二次首先将坐标轴向右下角平移了一段距离，然后绘制出的坐标系也就整体向右下角平移了；第三次再次向右下角平移，并旋转了30度，图上倾斜的坐标系即最后的绘图坐标系","text":"Canvas绘图中牵扯到两种坐标系：Canvas坐标系与绘图坐标系。Canvas坐标系Canvas坐标系指的是Canvas本身的坐标系，Canvas坐标系有且只有一个，且是唯一不变的，其坐标原点在View的左上角，从坐标原点向右为x轴的正半轴，从坐标原点向下为y轴的正半轴。 绘图坐标系Canvas的drawXXX方法中传入的各种坐标指的都是绘图坐标系中的坐标，而非Canvas坐标系中的坐标。默认情况下，绘图坐标系与Canvas坐标系完全重合，即初始状况下，绘图坐标系的坐标原点也在View的左上角，从原点向右为x轴正半轴，从原点向下为y轴正半轴。但不同于Canvas坐标系，绘图坐标系并不是一成不变的，可以通过调用Canvas的translate方法平移坐标系，可以通过Canvas的rotate方法旋转坐标系，还可以通过Canvas的scale方法缩放坐标系，而且需要注意的是，translate、rotate、scale的操作都是基于当前绘图坐标系的，而不是基于Canvas坐标系，一旦通过以上方法对坐标系进行了操作之后，当前绘图坐标系就变化了，以后绘图都是基于更新的绘图坐标系了。也就是说，真正对我们绘图有用的是绘图坐标系而非Canvas坐标系。 为了更好的理解绘图坐标系，请看如下的代码： 1//绘制坐标系2 private void drawAxis(Canvas canvas)&#123;3 int canvasWidth = canvas.getWidth();4 int canvasHeight = canvas.getHeight();5 paint.setStyle(Paint.Style.STROKE);6 paint.setStrokeCap(Paint.Cap.ROUND);7 paint.setStrokeWidth(6 * density);8 9 //用绿色画x轴，用蓝色画y轴10 11 //第一次绘制坐标轴12 paint.setColor(0xff00ff00);//绿色13 canvas.drawLine(0, 0, canvasWidth, 0, paint);//绘制x轴14 paint.setColor(0xff0000ff);//蓝色15 canvas.drawLine(0, 0, 0, canvasHeight, paint);//绘制y轴16 17 //对坐标系平移后，第二次绘制坐标轴18 canvas.translate(canvasWidth / 4, canvasWidth /4);//把坐标系向右下角平移19 paint.setColor(0xff00ff00);//绿色20 canvas.drawLine(0, 0, canvasWidth, 0, paint);//绘制x轴21 paint.setColor(0xff0000ff);//蓝色22 canvas.drawLine(0, 0, 0, canvasHeight, paint);//绘制y轴23 24 //再次平移坐标系并在此基础上旋转坐标系，第三次绘制坐标轴25 canvas.translate(canvasWidth / 4, canvasWidth / 4);//在上次平移的基础上再把坐标系向右下角平移26 canvas.rotate(30);//基于当前绘图坐标系的原点旋转坐标系27 paint.setColor(0xff00ff00);//绿色28 canvas.drawLine(0, 0, canvasWidth, 0, paint);//绘制x轴29 paint.setColor(0xff0000ff);//蓝色30 canvas.drawLine(0, 0, 0, canvasHeight, paint);//绘制y轴31 &#125; 第一次绘制绘图坐标系时，绘图坐标系默认情况下和Canvas坐标系重合，所以绘制出的坐标系紧贴View的上侧和左侧；第二次首先将坐标轴向右下角平移了一段距离，然后绘制出的坐标系也就整体向右下角平移了；第三次再次向右下角平移，并旋转了30度，图上倾斜的坐标系即最后的绘图坐标系","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Fragment懒加载","slug":"Fragment懒加载","date":"2019-12-13T09:43:29.195Z","updated":"2019-12-13T09:46:16.652Z","comments":true,"path":"2019/12/13/Fragment懒加载/","link":"","permalink":"http://yoursite.com/2019/12/13/Fragment%E6%87%92%E5%8A%A0%E8%BD%BD/","excerpt":"Fragment的懒加载的一般实现方案:1public abstract class LazyFragment extends Fragment &#123;2 /**3 * 标记已加载完成，保证懒加载只能加载一次4 */5 private boolean hasLoaded = false;6 /**7 * 标记Fragment是否已经onCreate8 */9 private boolean isCreated = false;10 /**11 * 界面对于用户是否可见12 */13 private boolean isVisibleToUser = false;14 private View view;15 16 public LazyFragment() &#123;17 // Required empty public constructor18 &#125;19 20 21 @Override22 public View onCreateView(LayoutInflater inflater, ViewGroup container,23 Bundle savedInstanceState) &#123;24 init(getView(inflater, getLayoutId(), container), savedInstanceState);25 return view;26 &#125;27 28 private View getView(LayoutInflater inflater, int layoutId, ViewGroup container) &#123;29 return inflater.inflate(layoutId, container, false);30 &#125;31 32 33 public void init(View view, Bundle savedInstanceState) &#123;34 isCreated = true;35 this.view = view;36 initViews(this.view,savedInstanceState);37 lazyLoad(this.view,savedInstanceState);38 &#125;39 /**40 * 监听界面是否展示给用户，实现懒加载41 * 这个方法也是网上的一些方法用的最多的一个，我的思路也是这个，不过把整体思路完善了一下42 */43 @Override44 public void setUserVisibleHint(boolean isVisibleToUser) &#123;45 Log.i(\"TAG\", \"setUserVisibleHint: \");46 //注：关键步骤47 this.isVisibleToUser = isVisibleToUser;48 lazyLoad(view, null);49 &#125;50 /**51 * 视图初始化52 */53 public abstract void initViews(View view,Bundle savedInstanceState);54 55 56 /**57 * 懒加载方法，获取数据什么的放到这边来使用，在切换到这个界面时才进行网络请求58 */59 private void lazyLoad(View view, Bundle savedInstanceState) &#123;60 61 //如果该界面不对用户显示、已经加载、fragment还没有创建，62 //三种情况任意一种，不获取数据63 if (!isVisibleToUser || hasLoaded || !isCreated) &#123;64 return;65 &#125;66 lazyInit(view, savedInstanceState);67 //注：关键步骤，确保数据只加载一次68 hasLoaded = true;69 &#125;70 71 /**72 * 子类必须实现的方法，这个方法里面的操作都是需要懒加载的73 */74 public abstract void lazyInit(View view, Bundle savedInstanceState);75 /**76 * Fragment布局77 */78 public abstract int getLayoutId();79 80 81 @Override82 public void onDestroyView() &#123;83 super.onDestroyView();84 isCreated = false;85 hasLoaded = false;86 &#125;87&#125;","text":"Fragment的懒加载的一般实现方案:1public abstract class LazyFragment extends Fragment &#123;2 /**3 * 标记已加载完成，保证懒加载只能加载一次4 */5 private boolean hasLoaded = false;6 /**7 * 标记Fragment是否已经onCreate8 */9 private boolean isCreated = false;10 /**11 * 界面对于用户是否可见12 */13 private boolean isVisibleToUser = false;14 private View view;15 16 public LazyFragment() &#123;17 // Required empty public constructor18 &#125;19 20 21 @Override22 public View onCreateView(LayoutInflater inflater, ViewGroup container,23 Bundle savedInstanceState) &#123;24 init(getView(inflater, getLayoutId(), container), savedInstanceState);25 return view;26 &#125;27 28 private View getView(LayoutInflater inflater, int layoutId, ViewGroup container) &#123;29 return inflater.inflate(layoutId, container, false);30 &#125;31 32 33 public void init(View view, Bundle savedInstanceState) &#123;34 isCreated = true;35 this.view = view;36 initViews(this.view,savedInstanceState);37 lazyLoad(this.view,savedInstanceState);38 &#125;39 /**40 * 监听界面是否展示给用户，实现懒加载41 * 这个方法也是网上的一些方法用的最多的一个，我的思路也是这个，不过把整体思路完善了一下42 */43 @Override44 public void setUserVisibleHint(boolean isVisibleToUser) &#123;45 Log.i(\"TAG\", \"setUserVisibleHint: \");46 //注：关键步骤47 this.isVisibleToUser = isVisibleToUser;48 lazyLoad(view, null);49 &#125;50 /**51 * 视图初始化52 */53 public abstract void initViews(View view,Bundle savedInstanceState);54 55 56 /**57 * 懒加载方法，获取数据什么的放到这边来使用，在切换到这个界面时才进行网络请求58 */59 private void lazyLoad(View view, Bundle savedInstanceState) &#123;60 61 //如果该界面不对用户显示、已经加载、fragment还没有创建，62 //三种情况任意一种，不获取数据63 if (!isVisibleToUser || hasLoaded || !isCreated) &#123;64 return;65 &#125;66 lazyInit(view, savedInstanceState);67 //注：关键步骤，确保数据只加载一次68 hasLoaded = true;69 &#125;70 71 /**72 * 子类必须实现的方法，这个方法里面的操作都是需要懒加载的73 */74 public abstract void lazyInit(View view, Bundle savedInstanceState);75 /**76 * Fragment布局77 */78 public abstract int getLayoutId();79 80 81 @Override82 public void onDestroyView() &#123;83 super.onDestroyView();84 isCreated = false;85 hasLoaded = false;86 &#125;87&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://yoursite.com/tags/Fragment/"}]},{"title":"Android动画记录","slug":"Android动画","date":"2019-12-11T05:07:31.295Z","updated":"2019-12-18T06:44:11.016Z","comments":true,"path":"2019/12/11/Android动画/","link":"","permalink":"http://yoursite.com/2019/12/11/Android%E5%8A%A8%E7%94%BB/","excerpt":"可以通过动画添加视觉提示，向用户通知应用中的动态。当界面状态发生改变时（例如有新内容加载或有新操作可用时），动画尤其有用。动画还为应用增加了优美的外观，使其拥有更高品质的外观和风格.Android 根据您需要的动画类型提供不同的动画 API 帧动画将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果 实现案例1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;3 &lt;item4 android:drawable=\"@drawable/a_0\"5 android:duration=\"100\" /&gt;6 &lt;item7 android:drawable=\"@drawable/a_1\"8 android:duration=\"100\" /&gt;9 &lt;item10 android:drawable=\"@drawable/a_2\"11 android:duration=\"100\" /&gt;12&lt;/animation-list&gt;1314protected void onCreate(@Nullable Bundle savedInstanceState) &#123;15 super.onCreate(savedInstanceState);16 setContentView(R.layout.activity_frame_animation);17 ImageView animationImg1 = (ImageView) findViewById(R.id.animation1);18 animationImg1.setImageResource(R.drawable.frame_anim1);19 AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable();20 animationDrawable1.start();21 &#125; 补间动画 alpha 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:duration=\"1000\"4 android:fromAlpha=\"1.0\"5 android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"6 android:toAlpha=\"0.0\" /&gt; translate scale 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;scale xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:duration=\"1000\"4 android:fromXScale=\"0.0\"5 android:fromYScale=\"0.0\"6 android:pivotX=\"50%\"7 android:pivotY=\"50%\"8 android:toXScale=\"1.0\"9 android:toYScale=\"1.0\"/&gt; rotate 然后在Activity中 1Animation animation = AnimationUtils.loadAnimation(mContext, R.anim.alpha_anim);2img = (ImageView) findViewById(R.id.img);3img.startAnimation(animation);","text":"可以通过动画添加视觉提示，向用户通知应用中的动态。当界面状态发生改变时（例如有新内容加载或有新操作可用时），动画尤其有用。动画还为应用增加了优美的外观，使其拥有更高品质的外观和风格.Android 根据您需要的动画类型提供不同的动画 API 帧动画将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果 实现案例1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;3 &lt;item4 android:drawable=\"@drawable/a_0\"5 android:duration=\"100\" /&gt;6 &lt;item7 android:drawable=\"@drawable/a_1\"8 android:duration=\"100\" /&gt;9 &lt;item10 android:drawable=\"@drawable/a_2\"11 android:duration=\"100\" /&gt;12&lt;/animation-list&gt;1314protected void onCreate(@Nullable Bundle savedInstanceState) &#123;15 super.onCreate(savedInstanceState);16 setContentView(R.layout.activity_frame_animation);17 ImageView animationImg1 = (ImageView) findViewById(R.id.animation1);18 animationImg1.setImageResource(R.drawable.frame_anim1);19 AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable();20 animationDrawable1.start();21 &#125; 补间动画 alpha 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;alpha xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:duration=\"1000\"4 android:fromAlpha=\"1.0\"5 android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\"6 android:toAlpha=\"0.0\" /&gt; translate scale 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;scale xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:duration=\"1000\"4 android:fromXScale=\"0.0\"5 android:fromYScale=\"0.0\"6 android:pivotX=\"50%\"7 android:pivotY=\"50%\"8 android:toXScale=\"1.0\"9 android:toYScale=\"1.0\"/&gt; rotate 然后在Activity中 1Animation animation = AnimationUtils.loadAnimation(mContext, R.anim.alpha_anim);2img = (ImageView) findViewById(R.id.img);3img.startAnimation(animation); 也可以将多个动画集合在一起 1&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;2&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"3 android:interpolator=\"@[package:]anim/interpolator_resource\"4 android:shareInterpolator=[\"true\" | \"false\"] &gt;5 &lt;alpha6 android:fromAlpha=\"float\"7 android:toAlpha=\"float\" /&gt;8 &lt;scale9 android:fromXScale=\"float\"10 android:toXScale=\"float\"11 android:fromYScale=\"float\"12 android:toYScale=\"float\"13 android:pivotX=\"float\"14 android:pivotY=\"float\" /&gt;15 &lt;translate16 android:fromXDelta=\"float\"17 android:toXDelta=\"float\"18 android:fromYDelta=\"float\"19 android:toYDelta=\"float\" /&gt;20 &lt;rotate21 android:fromDegrees=\"float\"22 android:toDegrees=\"float\"23 android:pivotX=\"float\"24 android:pivotY=\"float\" /&gt;25 &lt;set&gt;26 ...27 &lt;/set&gt;28&lt;/set&gt; 属性动画1private void RotateAnimation() &#123;2 ObjectAnimator anim = ObjectAnimator.ofFloat(myView, \"rotation\", 0f, 360f);3 anim.setDuration(1000);4 anim.start();5 &#125;67 private void AlpahAnimation() &#123;8 ObjectAnimator anim = ObjectAnimator.ofFloat(myView, \"alpha\", 1.0f, 0.8f, 0.6f, 0.4f, 0.2f, 0.0f);9 anim.setRepeatCount(-1);10 anim.setRepeatMode(ObjectAnimator.REVERSE);11 anim.setDuration(2000);12 anim.start();13 &#125; 属性动画集： 1 ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(myView, \"alpha\", 1.0f, 0.5f, 0.8f, 1.0f);2 ObjectAnimator scaleXAnim = ObjectAnimator.ofFloat(myView, \"scaleX\", 0.0f, 1.0f);3 ObjectAnimator scaleYAnim = ObjectAnimator.ofFloat(myView, \"scaleY\", 0.0f, 2.0f);4 ObjectAnimator rotateAnim = ObjectAnimator.ofFloat(myView, \"rotation\", 0, 360);5 ObjectAnimator transXAnim = ObjectAnimator.ofFloat(myView, \"translationX\", 100, 400);6 ObjectAnimator transYAnim = ObjectAnimator.ofFloat(myView, \"tranlsationY\", 100, 750);7 AnimatorSet set = new AnimatorSet();8 set.playTogether(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);9// set.playSequentially(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);10 set.setDuration(3000);11 set.start(); Note:TypeEvaluator 决定了动画如何从初始值过渡到结束值。TimeInterpolator 决定了动画从初始值过渡到结束值的节奏 自定义TypeEvaluator 1public class PointSinEvaluator implements TypeEvaluator &#123;23 @Override4 public Object evaluate(float fraction, Object startValue, Object endValue) &#123;5 Point startPoint = (Point) startValue;6 Point endPoint = (Point) endValue;7 float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());89 float y = (float) (Math.sin(x * Math.PI / 180) * 100) + endPoint.getY() / 2;10 Point point = new Point(x, y);11 return point;12 &#125;13&#125;14，第一个参数fraction 代表当前动画完成的百分比，这个值是如何变化的后面还会提到；第二个和第三个参数代表动画的初始值和结束值1516Point startP = new Point(RADIUS, RADIUS);//初始值（起点）17 Point endP = new Point(getWidth() - RADIUS, getHeight() - RADIUS);//结束值（终点）18 final ValueAnimator valueAnimator = ValueAnimator.ofObject(new PointSinEvaluator(), startP, endP);19 valueAnimator.setRepeatCount(-1);20 valueAnimator.setRepeatMode(ValueAnimator.REVERSE);21 valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;22 @Override23 public void onAnimationUpdate(ValueAnimator animation) &#123;24 currentPoint = (Point) animation.getAnimatedValue();25 postInvalidate();26 &#125;27 &#125;); 属性动画当然也可以使用xml文件的方式实现 1&lt;set android:ordering=\"sequentially\"&gt;2 &lt;set&gt;3 &lt;objectAnimator4 android:propertyName=\"x\"5 android:duration=\"500\"6 android:valueTo=\"400\"7 android:valueType=\"intType\"/&gt;8 &lt;objectAnimator9 android:propertyName=\"y\"10 android:duration=\"500\"11 android:valueTo=\"300\"12 android:valueType=\"intType\"/&gt;13 &lt;/set&gt;14 &lt;objectAnimator15 android:propertyName=\"alpha\"16 android:duration=\"500\"17 android:valueTo=\"1f\"/&gt;18&lt;/set&gt;1920AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,21 R.anim.property_animator);22set.setTarget(myObject);23set.start();","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Animation","slug":"Animation","permalink":"http://yoursite.com/tags/Animation/"}]},{"title":"Java线程池记录","slug":"Java线程池","date":"2019-12-10T05:51:19.294Z","updated":"2019-12-12T09:18:16.105Z","comments":true,"path":"2019/12/10/Java线程池/","link":"","permalink":"http://yoursite.com/2019/12/10/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"构造一个线程池为什么需要几个参数？如果避免线程池出现OOM？Runnable和Callable的区别是什么？ Thread/Runnable/Callable 继承Thread1class MyThread extend Thread()&#123;2 @Override3 public void run() &#123;4 super.run();5 Log.i(Thread.currentThread().getId());6 &#125;7&#125;8new MyThread().start(); Runnable1class MyThread implements Runnable&#123;2 @Override3 public void run() &#123;4 Log.i(\"MyThread\", Thread.currentThread().getName());5 &#125;6&#125;7MyThreaed myThread = new MyThread();8new Thread(myThread).start(); Callable 的 call() 方法可以返回值和抛出异常,Callable 可以返回装载有计算结果的 Future 对象。 比较结论 Callable 接口下的方法是 call()，Runnable 接口的方法是 run()； Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的； call() 方法可以抛出异常，run()方法不可以的；运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果 ThreadPoolExecutor1public ThreadPoolExecutor(int corePoolSize,2 int maximumPoolSize,3 long keepAliveTime,4 TimeUnit unit,5 BlockingQueue&lt;Runnable&gt; workQueue) &#123;6 this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,7 Executors.defaultThreadFactory(), defaultHandler);8&#125; corePoolSize，线程池中核心线程的数量，默认情况下，即使核心线程没有任务在执行它也存在的，我们固定一定数量的核心线程且它一直存活这样就避免了一般情况下CPU创建和销毁线程带来的开销。我们如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程就会有超时策略，这个时间由keepAliveTime来设定，即keepAliveTime时间内如果核心线程没有回应则该线程就会被终止。allowCoreThreadTimeOut默认为false，核心线程没有超时时间。 maximumPoolSize，线程池中的最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数=核心线程+非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。 keepAliveTime，非核心线程的超时时长，当执行时间超过这个时间时，非核心线程就会被回收。当allowCoreThreadTimeOut设置为true时，此属性也作用在核心线程上。 unit，枚举时间单位，TimeUnit。 workQueue，线程池中的任务队列，我们提交给线程池的runnable会被存储在这个对象上。 线程池的分配遵循这样的规则： 当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务； 如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行； 如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务； 如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且ThreadPoolExecutor会调用RejectedtionHandler的rejectedExecution方法来通知调用者。","text":"构造一个线程池为什么需要几个参数？如果避免线程池出现OOM？Runnable和Callable的区别是什么？ Thread/Runnable/Callable 继承Thread1class MyThread extend Thread()&#123;2 @Override3 public void run() &#123;4 super.run();5 Log.i(Thread.currentThread().getId());6 &#125;7&#125;8new MyThread().start(); Runnable1class MyThread implements Runnable&#123;2 @Override3 public void run() &#123;4 Log.i(\"MyThread\", Thread.currentThread().getName());5 &#125;6&#125;7MyThreaed myThread = new MyThread();8new Thread(myThread).start(); Callable 的 call() 方法可以返回值和抛出异常,Callable 可以返回装载有计算结果的 Future 对象。 比较结论 Callable 接口下的方法是 call()，Runnable 接口的方法是 run()； Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值的； call() 方法可以抛出异常，run()方法不可以的；运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果 ThreadPoolExecutor1public ThreadPoolExecutor(int corePoolSize,2 int maximumPoolSize,3 long keepAliveTime,4 TimeUnit unit,5 BlockingQueue&lt;Runnable&gt; workQueue) &#123;6 this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,7 Executors.defaultThreadFactory(), defaultHandler);8&#125; corePoolSize，线程池中核心线程的数量，默认情况下，即使核心线程没有任务在执行它也存在的，我们固定一定数量的核心线程且它一直存活这样就避免了一般情况下CPU创建和销毁线程带来的开销。我们如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程就会有超时策略，这个时间由keepAliveTime来设定，即keepAliveTime时间内如果核心线程没有回应则该线程就会被终止。allowCoreThreadTimeOut默认为false，核心线程没有超时时间。 maximumPoolSize，线程池中的最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数=核心线程+非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。 keepAliveTime，非核心线程的超时时长，当执行时间超过这个时间时，非核心线程就会被回收。当allowCoreThreadTimeOut设置为true时，此属性也作用在核心线程上。 unit，枚举时间单位，TimeUnit。 workQueue，线程池中的任务队列，我们提交给线程池的runnable会被存储在这个对象上。 线程池的分配遵循这样的规则： 当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务； 如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行； 如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务； 如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且ThreadPoolExecutor会调用RejectedtionHandler的rejectedExecution方法来通知调用者。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Thread","slug":"Thread","permalink":"http://yoursite.com/tags/Thread/"}]}]}